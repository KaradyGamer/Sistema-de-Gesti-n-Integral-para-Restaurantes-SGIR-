# üîç AN√ÅLISIS EXHAUSTIVO DE FALLAS L√ìGICAS DEL SISTEMA

**Fecha**: 2025-10-15
**Versi√≥n Analizada**: 2.0.0
**Analista**: Claude Code (Asistente IA)

---

## üìä RESUMEN EJECUTIVO

**Total de Problemas Encontrados**: 18
- üî¥ **Cr√≠ticos**: 5 (requieren atenci√≥n inmediata)
- üü† **Altos**: 7 (pueden causar problemas serios)
- üü° **Medios**: 4 (inconsistencias menores)
- üü¢ **Bajos**: 2 (mejoras recomendadas)

---

## üî¥ FALLAS L√ìGICAS CR√çTICAS

### **CR√çTICO #1: Mesa con PROTECT permite eliminar si no tiene pedidos**
**Archivo**: `app/pedidos/models.py:28`
**C√≥digo**:
```python
mesa = models.ForeignKey('mesas.Mesa', on_delete=models.PROTECT, related_name='pedidos')
```

**Problema**:
- `PROTECT` solo bloquea si HAY pedidos relacionados
- Si una mesa NO tiene pedidos activos, puede eliminarse
- Pero la mesa puede tener:
  - Reservas futuras asignadas
  - Estar combinada con otras mesas
  - Tener QR code impreso en restaurante
  - Historial de transacciones

**Escenario de Falla**:
```
1. Mesa 5 tiene reserva para ma√±ana (estado='reservada')
2. No tiene pedidos ACTIVOS hoy
3. Admin elimina Mesa 5
4. ‚úÖ Django permite (no hay pedidos relacionados)
5. ‚ùå Reserva queda hu√©rfana (mesa=NULL por SET_NULL)
6. ‚ùå Ma√±ana cliente llega y no hay mesa asignada
```

**Impacto**: üî• ALTO - P√©rdida de reservas, confusi√≥n operativa

**Soluci√≥n Recomendada**:
```python
# Opci√≥n 1: No permitir eliminar mesas, solo desactivar
class Mesa(models.Model):
    disponible = models.BooleanField(default=True)
    eliminada = models.BooleanField(default=False)  # Soft delete

# Opci√≥n 2: Validar en delete() que no tenga reservas futuras
def delete(self, *args, **kwargs):
    from app.reservas.models import Reserva
    reservas_futuras = Reserva.objects.filter(
        mesa=self,
        estado__in=['pendiente', 'confirmada'],
        fecha_reserva__gte=timezone.now().date()
    ).exists()

    if reservas_futuras:
        raise ValidationError('No se puede eliminar mesa con reservas futuras')

    super().delete(*args, **kwargs)
```

---

### **CR√çTICO #2: Producto con PROTECT puede eliminarse**
**Archivo**: `app/pedidos/models.py:69`
**C√≥digo**:
```python
producto = models.ForeignKey('productos.Producto', on_delete=models.PROTECT, related_name='detalles_pedidos')
```

**Problema Similar a #1**:
- Solo protege si hay DetallePedido relacionados
- Pero si el producto:
  - Tiene stock (inventario activo)
  - Tiene alertas de stock bajo
  - Est√° en an√°lisis de reportes

**Puede eliminarse** si no tiene pedidos activos

**Impacto**: üî• MEDIO - P√©rdida de datos de inventario

**Soluci√≥n**: Soft delete en Producto tambi√©n

---

### **CR√çTICO #3: Cambio de precio de producto NO afecta pedidos pendientes**
**Archivo**: `app/productos/models.py:13`
**Problema**: No hay snapshot de precio al momento del pedido

**Escenario de Falla**:
```
1. Cerveza cuesta Bs/ 15
2. Cliente pide 5 cervezas (total: Bs/ 75)
3. Admin cambia precio a Bs/ 20
4. Cliente llega a pagar
5. ‚ùì ¬øPaga Bs/ 75 o Bs/ 100?
```

**Estado Actual**:
```python
# DetallePedido.subtotal se calcula en crear_pedido_cliente:
subtotal = producto.precio * cantidad  # Guarda subtotal fijo ‚úÖ
```

**An√°lisis**: ‚úÖ PARCIALMENTE CORRECTO
- El subtotal S√ç se guarda al crear el pedido
- El total del pedido tambi√©n se guarda
- PERO: No se guarda el precio unitario hist√≥rico

**Riesgo**: Si se modifica el pedido (agregar/quitar productos), ¬øqu√© precio se usa?

**Mejora Recomendada**:
```python
class DetallePedido(models.Model):
    pedido = models.ForeignKey(...)
    producto = models.ForeignKey(...)
    cantidad = models.PositiveIntegerField(default=1)
    precio_unitario = models.DecimalField(max_digits=10, decimal_places=2)  # ‚≠ê NUEVO
    subtotal = models.DecimalField(max_digits=10, decimal_places=2)

    def save(self, *args, **kwargs):
        if not self.precio_unitario:
            self.precio_unitario = self.producto.precio  # Snapshot
        if not self.subtotal:
            self.subtotal = self.precio_unitario * self.cantidad
        super().save(*args, **kwargs)
```

---

### **CR√çTICO #4: Cierre de jornada sin validar pedidos sin pagar**
**Archivo**: `app/caja/models.py` - CierreCaja
**Problema**: No hay validaci√≥n que impida cerrar jornada con pedidos pendientes de pago

**Escenario de Falla**:
```
1. Turno de ma√±ana: 10 pedidos, 8 pagados, 2 pendientes
2. Cajero cierra caja sin revisar
3. ‚úÖ Sistema permite cerrar
4. ‚ùå Pedidos pendientes quedan "hu√©rfanos"
5. ‚ùå Turno tarde no sabe si debe cobrarlos
6. ‚ùå Reporte de cierre incorrecto
```

**Impacto**: üî• MUY ALTO - P√©rdida de dinero, reportes incorrectos

**Soluci√≥n Recomendada**:
```python
# En api_views.py - cerrar_caja()
pedidos_pendientes = Pedido.objects.filter(
    estado_pago__in=['pendiente', 'parcial'],
    estado='entregado',  # Ya se entreg√≥ pero no se pag√≥
    fecha__date=cierre.fecha
).count()

if pedidos_pendientes > 0:
    return Response({
        'error': f'No se puede cerrar caja. Hay {pedidos_pendientes} pedidos pendientes de pago.',
        'pedidos_pendientes': pedidos_pendientes
    }, status=400)
```

---

### **CR√çTICO #5: Mesa "disponible" puede tener pedido "entregado" sin pagar**
**Problema**: Inconsistencia de estados

**Flujo Actual**:
```
1. Crear pedido ‚Üí Mesa = 'ocupada' ‚úÖ
2. Cocina prepara ‚Üí Pedido = 'listo' ‚úÖ
3. Mesero entrega ‚Üí Pedido = 'entregado' ‚úÖ
4. ‚ùì Mesa sigue 'ocupada'? ‚úÖ S√ç
5. Cajero cobra ‚Üí Pedido = 'pagado' ‚úÖ
6. ‚ùì Mesa vuelve 'disponible'? ‚úÖ S√ç (en api_views.py)
```

**An√°lisis**: ‚úÖ FLUJO CORRECTO implementado

**PERO**: ¬øQu√© pasa si mesero marca "entregado" por error y cliente a√∫n est√° comiendo?

**Pregunta para el usuario**:
> ¬øEl estado "entregado" significa que el cliente YA puede pagar, o que el mesero llev√≥ la comida pero cliente sigue comiendo?

**Recomendaci√≥n**: Agregar estado intermedio
```python
ESTADO_CHOICES = [
    ('pendiente', 'Pendiente'),
    ('en preparacion', 'En Preparaci√≥n'),
    ('listo', 'Listo'),
    ('entregado', 'Entregado'),
    ('consumiendo', 'Cliente Consumiendo'),  # ‚≠ê NUEVO
    ('solicitando_cuenta', 'Cliente Pidi√≥ Cuenta'),  # ‚≠ê NUEVO
]
```

---

## üü† PROBLEMAS ALTOS

### **ALTO #6: Usuario eliminado/desactivado con pedidos asignados**
**Archivo**: `app/pedidos/models.py:46, 49`
**C√≥digo**:
```python
cajero_responsable = models.ForeignKey(..., on_delete=models.SET_NULL, null=True)
mesero_comanda = models.ForeignKey(..., on_delete=models.SET_NULL, null=True)
```

**Problema**: `SET_NULL` permite eliminar usuario, pero:
- Pedidos activos quedan sin responsable
- Reportes pierden informaci√≥n de qui√©n atendi√≥
- Auditor√≠a incompleta

**Escenario**:
```
1. Mesero Juan toma 5 pedidos hoy
2. Admin elimina a Juan (renuncia)
3. ‚úÖ Django pone mesero_comanda=NULL
4. ‚ùå No se sabe qui√©n tom√≥ esos pedidos
5. ‚ùå Reportes de performance incompletos
```

**Soluci√≥n**: Soft delete en Usuario
```python
class Usuario(AbstractUser):
    activo = models.BooleanField(default=True)
    fecha_eliminacion = models.DateTimeField(null=True, blank=True)

    def delete(self, *args, **kwargs):
        # No eliminar f√≠sicamente
        self.activo = False
        self.fecha_eliminacion = timezone.now()
        self.save()
```

---

### **ALTO #7: Reserva en mesa "ocupada" permite crearse**
**Archivo**: `app/reservas/` - Sin validaci√≥n aparente

**Problema**: No hay validaci√≥n que impida crear reserva en mesa ya ocupada

**Escenario**:
```
1. Mesa 5 tiene pedido activo (ocupada)
2. Cliente hace reserva para hoy 20:00 en Mesa 5
3. ‚úÖ Sistema permite (no hay validaci√≥n)
4. ‚ùå A las 20:00 mesa sigue ocupada
5. ‚ùå Cliente reservado llega y no tiene mesa
```

**Soluci√≥n**: Validar en crear_reserva
```python
if mesa.estado != 'disponible':
    # Verificar si estar√° disponible a la hora de la reserva
    pedidos_activos = Pedido.objects.filter(
        mesa=mesa,
        estado__in=['pendiente', 'en preparacion', 'listo', 'entregado']
    ).exists()

    if pedidos_activos:
        raise ValidationError(f'Mesa {mesa.numero} est√° actualmente ocupada')
```

---

### **ALTO #8: Dos meseros pueden ocupar misma mesa simult√°neamente**
**Archivo**: `app/pedidos/views.py:124-139`
**Estado**: ‚úÖ YA CORREGIDO en v2.0.0

**C√≥digo Actual**:
```python
if mesa.estado != 'disponible':
    return Response({'error': '...'}, status=400)

pedido_existente = Pedido.objects.filter(
    mesa=mesa,
    estado__in=['pendiente', 'en preparacion', 'listo']
).exists()
```

**An√°lisis**: ‚úÖ CORRECTO - Valida estado y pedido existente

**PERO**: ¬øQu√© pasa con concurrencia?
```
Tiempo 0: Mesero A verifica mesa 5 ‚Üí disponible ‚úÖ
Tiempo 1: Mesero B verifica mesa 5 ‚Üí disponible ‚úÖ
Tiempo 2: Mesero A crea pedido ‚Üí mesa = ocupada
Tiempo 3: Mesero B crea pedido ‚Üí ‚ùå Deber√≠a fallar
```

**Soluci√≥n**: Usar select_for_update()
```python
with transaction.atomic():
    mesa = Mesa.objects.select_for_update().get(numero=mesa_id)

    if mesa.estado != 'disponible':
        return Response({'error': '...'}, status=400)

    # Resto del c√≥digo...
```

---

### **ALTO #9: Mesas combinadas sin transacci√≥n at√≥mica**
**Archivo**: `app/mesas/utils.py` - funciones `combinar_mesas()` y `separar_mesas()`

**Problema**: Si falla a mitad de combinaci√≥n, quedan inconsistentes

**Soluci√≥n**: Agregar `@transaction.atomic`
```python
from django.db import transaction

@transaction.atomic
def combinar_mesas(mesas_list, estado='reservada'):
    # c√≥digo actual...
```

---

### **ALTO #10: Stock puede quedar negativo en rollback parcial**
**Archivo**: `app/pedidos/views.py:207-224`
**C√≥digo Actual**:
```python
stock_descontado = producto.descontar_stock(cantidad)

if not stock_descontado:
    pedido.delete()  # Rollback
    mesa.estado = 'disponible'
    mesa.save()
    return Response({'error': '...'}, status=400)
```

**Problema**: ¬øQu√© pasa si YA se descont√≥ stock de 3 productos y el 4to falla?

**Escenario**:
```
Pedido: Pizza (stock ok), Pasta (stock ok), Cerveza (stock ok), Postre (SIN STOCK)
1. Pizza: stock 10 ‚Üí 9 ‚úÖ
2. Pasta: stock 5 ‚Üí 4 ‚úÖ
3. Cerveza: stock 20 ‚Üí 19 ‚úÖ
4. Postre: stock 0 ‚Üí FALLA ‚ùå
5. pedido.delete() se ejecuta
6. ‚ùì ¬øSe restaura stock de Pizza, Pasta, Cerveza?
```

**Respuesta**: ‚ùå NO - El stock NO se restaura autom√°ticamente

**Impacto**: Stock queda descontado sin pedido

**Soluci√≥n**: Implementar rollback manual de stock
```python
productos_descontados = []

for item in productos_data:
    producto = Producto.objects.get(id=producto_id)
    stock_descontado = producto.descontar_stock(cantidad)

    if not stock_descontado:
        # RESTAURAR stock de productos anteriores
        for prod, cant in productos_descontados:
            prod.agregar_stock(cant)

        pedido.delete()
        mesa.estado = 'disponible'
        mesa.save()
        return Response({'error': '...'}, status=400)

    productos_descontados.append((producto, cantidad))
```

---

### **ALTO #11: Pago parcial sin validar monto**
**Archivo**: `app/caja/api_views.py` - procesar_pago

**Problema**: No valida que pago parcial sea menor que total

**Escenario**:
```
Total pedido: Bs/ 100
Cliente "paga parcial": Bs/ 150 ‚ùå
Sistema acepta
```

**Soluci√≥n**: Validar en API
```python
if estado_pago == 'parcial':
    if monto_pagado >= total_final:
        return Response({
            'error': 'Pago parcial debe ser menor que el total'
        }, status=400)
```

---

### **ALTO #12: Producto descontado puede quedar con stock negativo en race condition INTERNA**
**Archivo**: `app/productos/models.py:49-53`
**C√≥digo Actual** (ya corregido):
```python
updated = Producto.objects.filter(
    id=self.id,
    stock_actual__gte=cantidad
).update(stock_actual=F('stock_actual') - cantidad)
```

**An√°lisis**: ‚úÖ CORRECTO - Usa F() expression

**PERO**: ¬øQu√© pasa si entre el `.filter()` y el `.update()` otro proceso cambia el stock?

**Respuesta**: ‚úÖ NO HAY PROBLEMA - `F()` expression es at√≥mica a nivel de base de datos

**Estado**: ‚úÖ CORRECTO

---

## üü° PROBLEMAS MEDIOS

### **MEDIO #13: Total de pedido puede no coincidir con suma de detalles**
**Archivo**: `app/pedidos/views.py:194-196`
**C√≥digo**:
```python
pedido.total = total_calculado
pedido.save()
```

**Problema**: Si se modifican detalles despu√©s (agregar/quitar productos), total queda desactualizado

**Soluci√≥n**: Usar m√©todo en modelo
```python
class Pedido(models.Model):
    # ...

    def calcular_total(self):
        """Calcula total desde detalles"""
        return sum(d.subtotal for d in self.detalles.all())

    def save(self, *args, **kwargs):
        if self.pk:  # Si ya existe, recalcular
            self.total = self.calcular_total()
        super().save(*args, **kwargs)
```

---

### **MEDIO #14: Reserva vencida no se marca autom√°ticamente**
**Archivo**: `app/reservas/models.py:77-86`

**Problema**: M√©todo `esta_vencida()` existe pero no se ejecuta autom√°ticamente

**Soluci√≥n**: Tarea programada (Celery)
```python
from celery import shared_task

@shared_task
def marcar_reservas_vencidas():
    reservas_vencidas = Reserva.objects.filter(
        estado='confirmada',
        fecha_reserva__lt=timezone.now().date()
    )

    for reserva in reservas_vencidas:
        if reserva.esta_vencida():
            reserva.estado = 'no_show'
            reserva.save()
```

---

### **MEDIO #15: QR de mesa puede apuntar a URL incorrecta en producci√≥n**
**Archivo**: `app/mesas/models.py:67-74`
**C√≥digo**:
```python
try:
    domain = Site.objects.get_current().domain
    protocol = 'https' if settings.DEBUG is False else 'http'
except:
    domain = '127.0.0.1:8000'
    protocol = 'http'
```

**Problema**: Si falla `Site.objects.get_current()`, usa localhost

**Soluci√≥n**: Usar variable de entorno
```python
from decouple import config

domain = config('SITE_DOMAIN', default='127.0.0.1:8000')
protocol = config('SITE_PROTOCOL', default='http')
```

---

### **MEDIO #16: Campos nullable innecesariamente**
**Ejemplos**:
- `Pedido.observaciones` = NULL o blank?
- `Pedido.observaciones_caja` = NULL o blank?

**Recomendaci√≥n**: Usar `blank=True, default=''` en lugar de `null=True` para CharField/TextField

**Raz√≥n**: Evita dos estados vac√≠os (NULL vs '')

---

## üü¢ MEJORAS RECOMENDADAS

### **BAJO #17: Falta logging de operaciones cr√≠ticas**
**Recomendaci√≥n**: Agregar logs en:
- Cierre de caja
- Liberaci√≥n de mesas
- Cambios de estado de pedidos

---

### **BAJO #18: Sin rate limiting en APIs p√∫blicas**
**Archivo**: `app/pedidos/views.py:55` - `crear_pedido_cliente`

**Problema**: `@permission_classes([AllowAny])` sin rate limit

**Soluci√≥n**: Django Ratelimit
```python
from django_ratelimit.decorators import ratelimit

@ratelimit(key='ip', rate='10/m', method='POST')
@api_view(['POST'])
@permission_classes([AllowAny])
def crear_pedido_cliente(request):
    # ...
```

---

## ‚ùì PREGUNTAS PARA EL USUARIO

### **Pregunta #1: Flujo de "Entregado"**
> ¬øEl estado "entregado" significa:
> A) Mesero llev√≥ comida y cliente puede pagar inmediatamente
> B) Mesero llev√≥ comida pero cliente sigue comiendo (mesa a√∫n ocupada)

**Importancia**: Define si mesa se libera al entregar o al pagar

---

### **Pregunta #2: Eliminaci√≥n de Datos**
> ¬øNecesitan mantener historial completo de:
> - Mesas eliminadas
> - Productos descontinuados
> - Usuarios que renunciaron

**Si S√ç**: Implementar soft delete en todos los modelos

---

### **Pregunta #3: Modificaci√≥n de Pedidos**
> ¬øSe permite modificar un pedido despu√©s de creado?
> - ¬øPuede agregar productos?
> - ¬øPuede quitar productos?
> - ¬øPuede cambiar cantidades?

**Actual**: Hay funci√≥n `modificar_pedido()` en caja pero no validaciones claras

---

### **Pregunta #4: Pagos Parciales**
> ¬øEscenario de pago parcial?
> - Cliente paga parte y se va?
> - Cliente paga en dos momentos?
> - Varios clientes en misma mesa pagan por separado?

**Importancia**: Define l√≥gica de liberaci√≥n de mesa

---

### **Pregunta #5: Reservas Simult√°neas**
> ¬øUna mesa puede tener m√∫ltiples reservas el mismo d√≠a?
> - Reserva 12:00-14:00
> - Reserva 19:00-21:00

**Actual**: No hay validaci√≥n de overlapping

---

## üìã RESUMEN DE ACCIONES RECOMENDADAS

### **Inmediatas** (pr√≥xima semana):
1. ‚úÖ Implementar soft delete en Usuario, Mesa, Producto
2. ‚úÖ Validar cierre de caja con pedidos pendientes
3. ‚úÖ Rollback manual de stock en crear_pedido
4. ‚úÖ select_for_update() en ocupar mesa

### **Corto plazo** (pr√≥ximo mes):
5. ‚úÖ Agregar estado "consumiendo" en pedidos
6. ‚úÖ Validar overlapping de reservas
7. ‚úÖ Snapshot de precio en DetallePedido
8. ‚úÖ Transacciones at√≥micas en mesas combinadas

### **Mediano plazo** (2-3 meses):
9. ‚úÖ Tarea programada para reservas vencidas
10. ‚úÖ Rate limiting en APIs p√∫blicas
11. ‚úÖ Logging completo de operaciones
12. ‚úÖ Campo precio_unitario hist√≥rico

---

**Fin del An√°lisis**
